{
	"CP Boilerplate snippet": {
		"prefix": "snippet_cp_boilerplate",
		"body": [
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "#define pi acos(-1)",
		  "#define MOD 1000000007",
		  "#define inf 1000000010",
		  "#define endl \"\\n\"",
		  "#define ull unsigned long long",
		  "#define con (f?\"YES\":\"NO\")",
		  "",
		  "#define Dpos(n) fixed << setprecision(n)",
		  "",
		  "#define CLR(a) memset(a, -1, sizeof(a))",
		  "#define CLN(a) memset(a, 0, sizeof(a))",
		  "",
		  "#define max3(a,b,c) max(max(a,b),c)",
		  "#define min3(a,b,c) min(min(a,b),c)",
		  "#define max4(a,b,c,d) max(a,max3(b,c,d))",
		  "#define min4(a,b,c,d) min(a,min3(b,c,d))",
		  "#define max5(a,b,c,d,e) max(max4(a,b,c,d),e)",
		  "#define min5(a,b,c,d,e) min(min4(a,b,c,d),e)",
		  "",
		  "#define sortn(a,x,y) sort(a+x, a+x+y)",
		  "#define sortv(s) sort(s.begin(), s.end())",
		  "#define reversev(s) reverse(s.begin(), s.end())",
		  "#define reversesortv(s) sortv(s); reversev(s)",
		  "#define unik(a) unique(a.begin(), a.end()) - a.begin()",
		  "",
		  "#define lowerbound(v,x) lower_bound(v.begin(), v.end(), x)-v.begin()",
		  "#define upperbound(v,x) upper_bound(v.begin(), v.end(), x)-v.begin()",
		  "",
		  "#define pb push_back",
		  "#define loj(i,j) \"Case \"<<i<<\": \"<<j",
		  "#define gap \" \"",
		  "",
		  "#define auto(x,a) for (auto& x : a)",
		  "",
		  "int dx[] = {1, -1, 0, 0, 1, 1, -1, -1};",
		  "int dy[] = {0, 0, 1, -1, 1, -1, 1, -1};",
		  "",
		  "int main() {",
		  "   ios_base::sync_with_stdio(false); cin.tie(0),cout.tie(0);",
		  "",
		  "    long long t;",
		  "    cin >> t;",
		  "    while (t--) {",
		  "        long long n;",
		  "        cin>>n;",
		  "        ",
		  "        long long a[n+2];",
		  "        for(long long i=1;i<=n;i++) cin>>a[i];",
		  "",
		  "        for(long long i=1;i<=n;i++) cout<<a[i]<<\" \";",
		  "    }",
		  "}"
		],
		"description": "Boilerplate snippet"
	  },

	  "CP minimal boilerplate": {
		"prefix": "snippet_cp_minimal_boilerplate",
		"body": [
		  "#include<bits/stdc++.h>",
		  "using namespace std;",

		  "#define endl \"\\n\"",
		  "#define con (f?\"YES\":\"NO\")",

		  "#define loj(i,j) \"Case \"<<i<<\": \"<<j",

		  "",
		  "int main() {",
		  "   ios_base::sync_with_stdio(false); cin.tie(0),cout.tie(0);",
		  "",
		  "    long long t;",
		  "    cin >> t;",
		  "    while (t--) {",
		  "        long long n;",
		  "        cin>>n;",
		  "        ",
		  "        long long a[n+2];",
		  "        for(long long i=1;i<=n;i++) cin>>a[i];",
		  "",
		  "        for(long long i=1;i<=n;i++) cout<<a[i]<<\" \";",
		  "    }",
		  "}"
		],
		"description": "minimal boilerplate"
	  },

	  "BFS snippet": {
		"prefix": "snippet_graph_bfs",
		"body": [
		  "vector<int>p[20005];",
		  "",
		  "bool vis[20005]={};",
		  "",
		  "void Bfs(int x){",
		  "    queue<int>q;",
		  "    q.push(x);",
		  "",
		  "    vis[x]=true;",
		  "",
		  "    while(!q.empty()){",
		  "       int u=q.front();",
		  "       q.pop();",
		  "",
		  "       for(int i=0;i<p[u].size();i++){",
		  "       int v=p[u][i];",
		  "        if(!vis[v]){",
		  "            q.push(v);",
		  "            vis[v]=true;",
		  "        }",
		  "       }",
		  "    }",
		  "}"
		],
		"description": "BFS snippet"
	  },

	  "A array zigzag which count ground and peak.": {
		"prefix": "snippet_zigzag",
		"body": [
		  "int unique_zigzag(vector<int> a)",
		  "{",
		  "    int n, ans;",
		  "    ans = n = unique(a.begin(), a.end()) - a.begin();",
		  "    for (int i = 0; i < n - 2; i++) ans -= ((a[i] < a[i + 1] && a[i + 1] < a[i + 2]) + (a[i] > a[i + 1] && a[i + 1] > a[i + 2]));",
		  "    return ans;",
		  "}"
		],
		"description": "A array zigzag which count ground and peak."
	  } ,

	  	"Nth Prime Snippet": {
		"prefix": "snippet_number_theory_nthprime",
		"body": [
		  "int nth_prime[105], vis[105]={};",
		  "",
		  "void nthPrime(int limit=101){",
		  "    int ii=1;",
		  "    nth_prime[ii]=2;",
		  "    ",
		  "    for(int i=3;i<=limit;i+=2){",
		  "        if(!vis[i]){",
		  "            nth_prime[++ii]=i;",
		  "            for(int j=i*i;j<=limit;j+=i) vis[j]=1;",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Nth Prime Snippet"
	  },
	  
	  "Sum of absolute differences of all pairs in a given array": {
		"prefix": "snippet_sum_of_absolute_differences_of_all_pairs_in_a_given_array",
		"body": [
		  "int sum_of_absolute_differences_of_all_pairs_in_a_given_array(int a[], int n)",
		  "{",
		  "    int ans = 0;",
		  "    sort(a, a + n);",
		  "    for (long long i = 0; i < n; i++)",
		  "        ans += a[i] * (2 * i - n + 1);",
		  "    return ans;",
		  "}"
		],
		"description": "Sum of absolute differences of all pairs in a given array"
	  },
	  
	  "To check a prime number": {
		"prefix": "snippet_number_theory_isPrime",
		"body": [
		  "bool isPrime(int n){",
		  "    if(n==1) return false;",
		  "    for(int i=2;i*i<=n;i++) if(n%i==0) return false;",
		  "    return true;",
		  "}"
		],
		"description": "To check a prime number"
	  },

	  "DFS on tree": {
		"prefix": "snippet_graph_dfs_tree",
		"body": [
		  "/*",
		  "Snippet : DFS on tree",
		  "*/",
		  "",
		  "vector<vector<int>> p;",
		  "vector<long long> depth;",
		  "vector<long long> reverse_depth;",
		  "",
		  "void dfs(int u, int par)",
		  "{",
		  "    if (p[u].size() == 1 && p[u][0] == par){",
		  "        depth[u] = depth[par]+1;",
		  "        reverse_depth[u] = 1;",
		  "    }",
		  "    else",
		  "    {",
		  "        for (auto v : p[u])",
		  "        {",
		  "            if (v != par)",
		  "            {",
		  "                depth[v] = 1 + depth[u];",
		  "                dfs(v, u);",
		  "                reverse_depth[u] = 1 + reverse_depth[v];",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "void solve(int n)",
		  "{",
		  "    p.assign(n + 2, vector<int>());",
		  "    depth.assign(n + 2, 0);",
		  "    reverse_depth.assign(n + 2, 0);",
		  "",
		  "    for (int i = 1; i < n; i++)",
		  "    {",
		  "        int x, y;",
		  "        cin >> x >> y;",
		  "        p[x].push_back(y);",
		  "        p[y].push_back(x);",
		  "    }",
		  "    depth[1]=1;",
		  "    dfs(1, -1);",
		  "",
		  "    int x = 2;",
		  "",
		  "    cout<<depth[x]<<\" \"<<reverse_depth[x]<<endl;",
		  "}"
		],
		"description": "DFS on tree"
	  },
	  "Dijkstra for Matrics": {
		"prefix": "snippet_graph_dijkstra_matrix",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "int n, m;",
		  "int edges[1009][1009];",
		  "int dist[1009][1009];",
		  "int dx[] = {1, 0, -1, 0};",
		  "int dy[] = {0, 1, 0, -1};",
		  "",
		  "typedef pair<int, pair<int, int>> pi;",
		  "",
		  "",
		  "void dijkstra(int x, int y, int w) {",
		  "",
		  "   priority_queue<pi, vector<pi>, greater<pi>> pq;",
		  "",
		  "    pq.push({w, {x, y}});",
		  "    dist[x][y] = w;",
		  "",
		  "    while (!pq.empty()) {",
		  "        int curr_w = pq.top().first;",
		  "        int curr_x = pq.top().second.first;",
		  "        int curr_y = pq.top().second.second;",
		  "        pq.pop();",
		  "",
		  "        if (curr_w > dist[curr_x][curr_y])",
		  "            continue;",
		  "",
		  "        for (int i = 0; i < 4; i++) {",
		  "            int new_x = dx[i] + curr_x;",
		  "            int new_y = dy[i] + curr_y;",
		  "",
		  "            if (new_x <= n && new_x >= 1 && new_y <= m && new_y >= 1) {",
		  "                int new_w = curr_w + edges[new_x][new_y];",
		  "",
		  "                if (new_w < dist[new_x][new_y]) {",
		  "                    dist[new_x][new_y] = new_w;",
		  "                    pq.push({new_w, {new_x, new_y}});",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "",
		  "int main()",
		  "{",
		  "    ios_base::sync_with_stdio(false); cin.tie(0),cout.tie(0);",
		  "",
		  "",
		  "    int t;",
		  "    cin >> t;",
		  "",
		  "    for (int k = 1; k <= t; k++)",
		  "    {",
		  "",
		  "        cin >> n >> m;",
		  "",
		  "        for (int i = 0; i <= n + 2; i++)",
		  "        {",
		  "            for (int j = 0; j <= m + 2; j++)",
		  "            {",
		  "                dist[i][j] = 1<<30;",
		  "            }",
		  "        }",
		  "",
		  "        for (int i = 1; i <= n; i++)",
		  "        {",
		  "            for (int j = 1; j <= m; j++)",
		  "                cin >> edges[i][j];",
		  "        }",
		  "",
		  "        dijkstra(1, 1, edges[1][1]);",
		  "",
		  "        cout << dist[n][m] << endl;",
		  "    }",
		  "}",
		  "",
		  ""
		],
		"description": "Dijkstra for Matrics"
	  },
	  
	  "Total Number of divisors for a number up to n": {
		"prefix": "snippet_number_theory : Number of Divisors",
		"body": [
		  "/*",
		  "    1. Generate divisor of 1 to n",
		  "    2. Time complexity: O(nlogn)",
		  "    3. maximum n = 10^6",
		  "",
		  "    Usuage:",
		  "    1. Just call into main function - ",
		  "    vector<int>divisor = generateDivisor(n);",
		  "    2. divisor[12] = 6 ",
		  "*/",
		  "vector<int>generateDivisor(int n = 1e6){",
		  "    vector<int>divisor(n+1, 1);",
		  "    for(int i=2;i<=n;i++){",
		  "        if(divisor[i]==1){",
		  "            for(int j=i;j<=n;j+=i){",
		  "                int num = j, primeFactor = 0;",
		  "                while(num%i==0){",
		  "                    num/=i;",
		  "                    primeFactor++;",
		  "                }",
		  "                divisor[j] *= (primeFactor+1);",
		  "            }",
		  "        }",
		  "    }",
		  "    return divisor;",
		  "}"
		],
		"description": "Function generates divisors count for numbers up to n"
	  },

	  "Total Number of prime divisors for a number up to n": {
		"prefix": "snippet_number_theory: Number of Prime Divisors",
		"body": [
		  "/*",
		  "    1. Generate Prime Divisor of 1 to n",
		  "    2. Time complexity: O(n)",
		  "    3. maximum n = 10^6",
		  "",
		  "    Usuage:",
		  "    1. Just call into main function - ",
		  "    vector<int>primeDivisor = generateNumberOfPrimeDivisor(n);",
		  "    2. primeDivisor[12] = 6 ",
		  "*/",
		  "",
		  "vector<int>generateNumberOfPrimeDivisor(int n = 1e6){",
		  "    vector<int>primeDivisor(n+1, 0);",
		  "    for(int i=2;i<=n;i++){",
		  "        if(primeDivisor[i]==0){",
		  "            for(int j=i;j<=n;j+=i){",
		  "                primeDivisor[j] ++;",
		  "            }",
		  "        }",
		  "    }",
		  "    return primeDivisor;",
		  "}"
		],
		"description": "Function generates Prime Divisors count for numbers up to n"
	  },
	  "0-1 Knapsack Problem": {
		"prefix": "snippet_dp_knapsack",
		"body": [
		  "/*",
		  "    1. 0-1 Knapsack Problem",
		  "    2. Time complexity: O(n*W)",
		  "    3. Space complexity: O(n*W)",
		  "*/",
		  "",
		  "int knapSack(int W, int i, vector<int> &profit, vector<int> &weight, vector<vector<int>> &dp)",
		  "{",
		  "    if (i < 0)",
		  "        return 0;",
		  "    if (dp[W][i] != -1)",
		  "        return dp[W][i];",
		  "",
		  "    if (W < weight[i])",
		  "        dp[W][i] = knapSack(W, i - 1, profit, weight, dp);",
		  "    else",
		  "        dp[W][i] = max(knapSack(W, i - 1, profit, weight, dp), profit[i] + knapSack(W - weight[i], i - 1, profit, weight, dp));",
		  "",
		  "    return dp[W][i];",
		  "}",
		  "",
		  "void solve()",
		  "{",
		  "    int n, W;",
		  "    cin >> n >> W;",
		  "",
		  "    vector<int> profit(n);",
		  "    vector<int> weight(n);",
		  "",
		  "    for (int i = 0; i < n; i++)",
		  "        cin >> profit[i];",
		  "    for (int i = 0; i < n; i++)",
		  "        cin >> weight[i];",
		  "",
		  "    vector<vector<int>> dp(W + 1, vector<int>(n + 1, -1));",
		  "    cout << knapSack(W, n - 1, profit, weight, dp) << endl;",
		  "}",
		  ""
		],
		"description": "0-1 Knapsack Problem"
	  },
	  "Get sum of all divisor of a number": {
		"prefix": "snippet_number_theory: Get sum of all divisor of a number",
		"body": [
		  "/**",
		  "    Get sum of all divisor of a^b",
		  "",
		  "    1. Each of a and b will be fit into a 32 bit signed integer.",
		  "",
		  "    Usuage:",
		  "    1. just call, long long ans = getSumOfAllDivisor(a, b);",
		  "    2. a = 12, b = 1 , so ans = 28",
		  "*/",
		  "",
		  "long long MOD = 1000000007;",
		  "",
		  "long long bigMod(long long a, long long b)",
		  "{",
		  "    if (!b)",
		  "        return 1;",
		  "    long long res = bigMod(a, b >> 1);",
		  "    long long ans = (res * res) % MOD;",
		  "    if (b % 2)",
		  "        ans = (ans * a) % MOD;",
		  "    return ans;",
		  "}",
		  "",
		  "long long inverseMod(long long a)",
		  "{",
		  "    return bigMod(a, MOD - 2);",
		  "}",
		  "",
		  "void getPrimeFactorization(vector<long long> &primes, map<long long, long long> &freq, long long n)",
		  "{",
		  "    if (n % 2 == 0)",
		  "    {",
		  "        primes.push_back(2);",
		  "        while (n % 2 == 0)",
		  "        {",
		  "            freq[2]++;",
		  "            n >>= 1;",
		  "        }",
		  "    }",
		  "",
		  "    for (long long i = 3; i * i <= n; i += 2)",
		  "    {",
		  "        if (n % i == 0)",
		  "        {",
		  "            primes.push_back(i);",
		  "            while (n % i == 0)",
		  "            {",
		  "                freq[i]++;",
		  "                n /= i;",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    if (n > 1)",
		  "    {",
		  "        freq[n]++;",
		  "    }",
		  "",
		  "    if (freq[n] == 1)",
		  "        primes.push_back(n);",
		  "}",
		  "",
		  "long long getSumOfAllDivisor(long long a, long long b)",
		  "{",
		  "    vector<long long> primes;",
		  "    map<long long, long long> freq;",
		  "",
		  "    long long ans = 1;",
		  "",
		  "    getPrimeFactorization(primes, freq, a);",
		  "",
		  "    for (long long p : primes)",
		  "    {",
		  "        long long lob = bigMod(p, freq[p]*b + 1) - 1;",
		  "        if (lob < 0)",
		  "            lob += MOD;",
		  "        long long hor = inverseMod(p - 1);",
		  "",
		  "        lob *= hor;",
		  "",
		  "        ans = ((ans % MOD) * (lob % MOD)) % MOD;",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "Get sum of all divisor"
	  },
	  
	  "Big Mod": {
		"prefix": "snippet_number_theory: BigMod",
		"body": [
		  "/**",
		  "    BigMod of a^b",
		  "    1. Each of a and b will be fit into a 32 bit signed integer.",
		  "",
		  "    Usuage:",
		  "    1. just call, long long ans = bigMod(a, b);",
		  "*/",
		  "",
		  "long long MOD = 1000000007;",
		  "",
		  "long long bigMod(long long a, long long b)",
		  "{",
		  "    if (!b)",
		  "        return 1;",
		  "    long long res = bigMod(a, b >> 1);",
		  "    long long ans = (res * res) % MOD;",
		  "    if (b % 2)",
		  "        ans = (ans * a) % MOD;",
		  "    return ans;",
		  "}",
		  "",
		  "long long inverseMod(long long a)",
		  "{",
		  "    return bigMod(a, MOD - 2);",
		  "}"
		],
		"description": "Big Mod"
	  },

	  "check if the the graph is cycle": {
		"prefix": "snip_graph_isCycle",
		"body": [
		  "/*",
		  " vector<vector<int>>p(n+2)",
		  " vector<bool> vis;",
		  " u is where u want to start",
		  " prev is it's parent",
		  "",
		  " declare this in main function",
		  " then call isCycle",
		  "*/",
		  "",
		  "bool isCycle(vector<vector<int>>& p, vector<bool>& vis, int u, int prev=-1) {",
		  "    vis[u] = true;",
		  "    for (int v : p[u]) {",
		  "        if (v != prev) {",
		  "            if (vis[v]) {",
		  "                return true;",
		  "            }",
		  "            if (isCycle(p, vis, v, u)) {",
		  "                return true;",
		  "            }",
		  "        }",
		  "    }",
		  "    return false;",
		  "}"
		],
		"description": "check if the the graph is cycle"
	  },
	  "Graph essential": {
		"prefix": "snip_graph_essential",
		"body": [
		  "/*",
		  "        Graph essential",
		  "        */",
		  "        long long n, m;",
		  "        cin>>n>>m;",
		  "        //if tree",
		  "        //m = n-1",
		  "",
		  "        vector<vector<int>>p(n+2);",
		  "        ",
		  "        for(int i=1;i<m;i++){",
		  "            int x, y;",
		  "            cin>>x>>y;",
		  "            p[x].push_back(y);",
		  "            p[y].push_back(x);",
		  "        }"
		],
		"description": "Graph essential"
	  },
	  "LPS Table": {
		"prefix": "String: LPS Table",
		"body": [
		  "vector<int> lps(string pattern)",
		  "    {",
		  "        int n = pattern.size();",
		  "        vector<int> v(n);",
		  "        int index = 0;",
		  "",
		  "        for (int i = 1; i < n;)",
		  "        {",
		  "            if (pattern[i] == pattern[index])",
		  "            {",
		  "                v[i] = index + 1;",
		  "                i++;",
		  "                index++;",
		  "            }",
		  "            else",
		  "            {",
		  "                if (index)",
		  "                    index = v[index - 1];",
		  "                else",
		  "                {",
		  "                    v[i] = 0;",
		  "                    i++;",
		  "                }",
		  "            }",
		  "        }",
		  "        return v;",
		  "    }"
		],
		"description": "LPS Table"
	  },

	  "How many Pattern matching": {
		"prefix": "String: KMP- Number of pattern matching",
		"body": [
		  "    vector<int> lps(string pattern)",
		  "    {",
		  "        int n = pattern.size();",
		  "        vector<int> v(n);",
		  "        int index = 0;",
		  "",
		  "        for (int i = 1; i < n;)",
		  "        {",
		  "            if (pattern[i] == pattern[index])",
		  "            {",
		  "                v[i] = index + 1;",
		  "                i++;",
		  "                index++;",
		  "            }",
		  "            else",
		  "            {",
		  "                if (index)",
		  "                    index = v[index - 1];",
		  "                else",
		  "                {",
		  "                    v[i] = 0;",
		  "                    i++;",
		  "                }",
		  "            }",
		  "        }",
		  "        return v;",
		  "    }",
		  "",
		  "    int kmp(string s, string pattern)",
		  "    {",
		  "        int n = s.size(), m = pattern.size();",
		  "        int i = 0, j = 0;",
		  "        int ans = 0;",
		  "",
		  "        vector<int> v = lps(pattern);",
		  "",
		  "        while (i < n)",
		  "        {",
		  "            if (s[i] == pattern[j])",
		  "            {",
		  "                i++;",
		  "                j++;",
		  "            }",
		  "            else",
		  "            {",
		  "                if (j)",
		  "                    j = v[j - 1];",
		  "                else",
		  "                    i++;",
		  "            }",
		  "",
		  "            if (j == m) //to count how many pattern match",
		  "            {",
		  "                ans++;",
		  "                j = v[j - 1];",
		  "            }",
		  "        }",
		  "",
		  "        return ans;",
		  "    }"
		],
		"description": "How many Pattern matching"
	  },
}